Numerical Analysis  
Course Project 
 
This project is individual. No collaboration is allowed. Plagiarism will be checked and will not be 
tolerated (including reuse of the assignment solutions from past submissions). 
The programming language for this task is Python 3. You can use standard libraries coming with 
Anaconda distribution. In particular limited use of numpy and pytorch is allowed and highly encouraged.  
Comments within the Python templates of the assignment code are an integral part of the assignment 
instructions. You must follow the instructions in the assignment comments!   
You should not use those parts of the libraries that implement numerical methods taught in this 
course. This includes, for example, finding roots and intersections of functions, interpolation, 
integration, matrix decomposition, eigenvectors, solving linear systems, etc.  
The use of the following methods in the submitted code must be clearly announced in the beginning of 
the explanation of each assignment where it is used and will result in reduction of points: 
numpy.linalg.solve (15% of the assignment score)  
numpy.linalg.pinv, numpy.linalg.inv (10% of assignment 1 score) 
(not studied in class) numpy.linalg.cholesky, torch.cholesky, linalg.qr, torch.qr (1% of the assignment score) 
numpy.*.polyfit, numpy.*.*fit (40% of the assignment score) 
*. Lstsq (30% in assignments 1,3, 15% in assignment 2, 60% in assignment 4 
numpy.*.interpolate, torch.*.interpolate, scipy.interpolate.splprep, scipy.interpolate.splev (60% of the assignment score) 
numpy.*.roots (30% of the assignment 2 score and 15% of the assignment 3 score) 
 
All numeric differentiation functions are allowed (including gradients, and the gradient descent 
algorithm).  
Additional functions and penalties may be allowed according to the task forum.  
You must not use reflection (self-modifying or self-inspecting code).   
Attached are mockups of assignments where you need to add your code implementing the relevant 
functions. You can add classes and auxiliary methods as needed. Unittests found within the assignment 
files must pass before submission. You can add any number of additional unittests to ensure correctness 
of your implementation.  
In addition, attached are two supplementary python modules. You can use them but you cannot change 
them.  
Upon the completion of the final task, you should submit the four assignment files and this document 
with answers to the theoretical questions archived together in a file named <your ID>.zip 
Do not use any folders inside the ZIP file! If the zip will contain folders the assignment will not be 
checked. 
All assignments will be graded according to accuracy of the numerical solutions, running time, and 
special constraints specified in the grading policies.  
You are encouraged to reuse your own code in different assignments.  
Example test functions 
Expect that the assignment will be tested on various combinations of the arguments including function, 
ranges, target errors, and target time. We advise to use the functions listed below as test cases and 
benchmarks. At least half of the test functions will be polynomials. Functions like 3,8,10,11 will account 
for at most 4% of the test cases. All test functions are continuous in the given range. If no range is 
specified the function is continuous in [âˆ’âˆ, +âˆ]. 
1. ğ‘“1(ğ‘¥) = 5 
2. ğ‘“2(ğ‘¥) = ğ‘¥2 âˆ’ 3ğ‘¥ + 5 
3. ğ‘“3(ğ‘¥) =  ğ‘ ğ‘–ğ‘› (ğ‘¥2) 
4. ğ‘“4(ğ‘¥) = ğ‘’âˆ’2ğ‘¥2
 
5. ğ‘“5(ğ‘¥) =ğ‘ğ‘Ÿğ‘ğ‘¡ğ‘ğ‘› ğ‘ğ‘Ÿğ‘ğ‘¡ğ‘ğ‘› (ğ‘¥)  
6. ğ‘“6(ğ‘¥) =
ğ‘ ğ‘–ğ‘›ğ‘ ğ‘–ğ‘› (ğ‘¥) 
ğ‘¥  
7. ğ‘“7(ğ‘¥) =
1
ğ‘™ğ‘›ğ‘™ğ‘› (ğ‘¥)  
8. ğ‘“8(ğ‘¥) = ğ‘’ğ‘’ ğ‘¥ 
9. ğ‘“9(ğ‘¥) =ğ‘™ğ‘› ğ‘™ğ‘› (ğ‘™ğ‘› ğ‘™ğ‘› (ğ‘¥) )  
10. ğ‘“10(ğ‘¥) =ğ‘ ğ‘–ğ‘› ğ‘ ğ‘–ğ‘› (ğ‘™ğ‘› ğ‘™ğ‘› (ğ‘¥) )  
11. ğ‘“11(ğ‘¥) = 2
1
ğ‘¥2 âˆ—ğ‘ ğ‘–ğ‘› ğ‘ ğ‘–ğ‘› (
1
ğ‘¥)  
12. For Assignment 4 see sampleFunction.* 
  
Assignment 1 (10pt): 
Check comments in Assignment1.py. 
Implement the function Assignment1.interpolate(..). 
The function will receive a function f, a range, and a number of points to use n. 
The function will return another â€œinterpolatedâ€ function g. During testing, g will be called with various 
floats x to test for the interpolation errors.  
You can sample fewer than n  points, but sampling more than n points will result in an exception.  
It can be assumed that n<=100. 
 
Grading policy (10pt):  
Running time complexity = o(n^2): 0-8  
Running time complexity = O(n): 5-10 
The grade within the above ranges is a function of the average absolute error of the interpolation 
function at random test points. Correctly implemented linear splines will give you at least 5pt.   
Solutions will be tested with ğ‘› âˆˆ {1,10,20,50,100} on variety of functions at least half of which are 
polynomials of various degrees with coefficients ranging in [âˆ’1,1].  
  
Assignment 2 (10pt): 
Check comments in Assignment2.py. 
Implement the function Assignment2.intersections(..). 
The function will receive 2 functions- ğ‘“1, ğ‘“2, and a float maxerr. 
The function will return an iterable of approximate intersection Xs, such that: 
âˆ€ğ‘¥ âˆˆ ğ‘‹, |ğ‘“1(ğ‘¥) âˆ’ ğ‘“2(ğ‘¥)| < ğ‘šğ‘ğ‘¥ğ‘’ğ‘Ÿğ‘Ÿ 
Grading policy (10pt): The grade will be affected by the number of correct/incorrect intersection points 
found while the running time of Assignment2.intersections(..) is capped. 
 
  
 
